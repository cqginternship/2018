### Modern C++: lambda, bind, function
# Лабораторная работа

Есть 2 версии лабораторной работы: ООП и функциональная. Вы можете выбрать любую из них.
Функциональная работа сложнее, потому что использует непривычные конструкции,
но зато она немного интереснее и заставляет больше думать и чуть меньше писать.

## Задание для ООП программиста
### 1. Реализовать класс пользователя Twitter `Account` со следующим интерфейсом
```cpp
class Account
{
public:
   explicit Account(int i_id);
   void Tweet(const std::string& i_message);
   void ReTweet(int i_id, const std::string& i_message);
   void AddFollower(const std::function<void(int, const std::string&)>& i_callback);
   void SetAutoReTweet(Account& io_leader);
   const std::vector<std::string>& GetAllTweets() const;

private:
   const int m_id;
   std::vector<std::string> m_tweets; // содержит твиты и ретвиты
   std::vector<std::function<void(int, const std::string&)>> m_followers;
};
```
#### Описание функций
Конструктор. Создание пользователя с номером `i_id`.
```cpp
   explicit Account(int i_id);
```
Функция создания нового твита.
Должна добавлять новый твит `i_message` в `m_tweets` и уведомлять всех подписчиков `m_followers`.
```cpp
   void Tweet(const std::string& i_message);
```
Функция репоста чужого твита к себе на страницу.
`i_id` - номер пользователя, который сделал твит.
`i_message` - текст твита.
Твит добавляется в `m_tweets` в формате `i_id + ":" + i_message`. В этой функции уведомлять подписчиков не нужно, иначе может получиться циклическая зависимость.
```cpp
   void ReTweet(int i_id, const std::string& i_message);
```
Функция добавления подписки на этот аккаунт.
`i_callback` - callback, который необходимо вызвать при создании твита от этого аккаунта и передать id этого пользователя, и текст твита.
Добавление `i_callback` происходит в `m_followers`.
```cpp
   void AddFollower(const std::function<void(int, const std::string&)>& i_callback);
```
Функция настройки автоматического ретвита всех твитов `io_leader`.
Реализовать с помощью добавления в подписки `io_leader` лямбды или std::bind.
```cpp
   void SetAutoReTweet(Account& io_leader);
```
Функция получения всех твитов на странице пользователя.
```cpp
   const std::vector<std::string>& GetAllTweets() const;
```

### 2. Проверить работу созданного класса
1. Создать вектор пользователей;
2. Настроить автоматический ретвит некоторых пользователей другими пользователями;
3. Добавить подписку некоторым пользователям так, чтобы их твит выводился в консоль (добавить в подписки к ним лямбду, которая это делает);
4. Сделать твиты от некоторых пользователей;
5. Проверить, что при твите одного пользователя, все подписанные пользователи делают ретвиты;
6. Проверить, что появляются сообщения в консоли о новых твитах.

## Задание для функционального программиста
### Теория
В данной версии лабораторной всё передаётся по значению.
Конечно в реальных программах так писать не стоит, но можно в целях упрощения обучения.
Можете не беспокоиться о лишних копированиях.

Определим понятие потока. Поток - это бесконечная последовательность значений.
Это довольно часто встречающаяся вещь в computer science, просто мы редко об этом задумываемся.
Это последовательность действий пользователя, передаваемые по сети данные, и т.д.

Часто потоки просто помогают разделить ответственность между разными модулями программы,
когда один модуль умеет генерировать данные, второй умеет их модифицировать,
третий выбирает некоторую часть данных и считает результат.

В данной лабораторной работе необходимо создать функции, работающие с потоками.

Очевидно, мы не можем создать весь бесконечный поток явно.
Чтобы работать с такого рода вещами, необходимо применить идеи отложенного вычисления.
Мы будем знать только текущее значение потока `current` и отложенный оставшийся поток `next`.
``` cpp
template<class T>
struct Stream
{
   Stream(T current, std::function<Stream<T>()> next)
      : current(current)
      , next(next)
   {}
   T current;
   std::function<Stream<T>()> next;
};
```
Посмотрим на вывод первых 10 элементов потока:
``` cpp
for (int i = 0; i < 10; ++i)
{
  cout << stream.current << endl;
  stream = stream.next();
}
```

Часто при работе с подобными рекурсивными структурами данных необходимо использовать рекурсию.
Это понадобится сделать и для создания нашего потока.

Функция `CreateStream` создаёт поток из начального значения `init` и функции `fn`,
которая принимает текущее значение потока, и возвращает следующее.

Обратите внимание, что мы вызываем `CreateStream` рекурсивно внутри лямбды.
Это отложенное вычисление, которое будет произведено только когда мы захотим реально взять следующее значение потока.

``` cpp
template<class T, class TFn>
Stream<T> CreateStream(T init, TFn fn)
{
   return Stream<T>(init, [=] { return CreateStream(fn(init), fn); });
}
```

Вот примеры некоторых потоков, которые можно создать:
``` cpp
auto naturalNumbers = CreateStream(1, [](int i) { return i + 1; }); // 1, 2, 3, 4, 5, 6, 7...
auto powersOfTwo = CreateStream(2, [](int i) { return i * 2; }); // 2, 4, 8, 16, 32, 64, 128...
```

### 1. Создать функции для работы с потоками

Необходимо создать следующие функции для работы с потоками:

1. Функция `Take` возвращает первые `n` элементов потока `stream`.
    ``` cpp
    template<class T>
    vector<T> Take(Stream<T> stream, size_t n);

    Take(naturalNumbers, 5); // { 1, 2, 3, 4, 5 }
    ```

1. Функция `Map` применяет функцию `fn` ко всем элементам потока и возвращает получившийся поток.

    Возвращаемоe значение `Map` по сути означает поток типа, который возвращает функция `f`.
    Необязательно разбираться в `decay_t` и в `invoke_result_t`, чтобы написать эту функцию.
    `decay_t<invoke_result_t<TFn, T>>` - это возвращаемое значение `TFn` при передаче `T` как аргумента функции.
    ``` cpp
    template<class T, class TFn>
    Stream<decay_t<invoke_result_t<TFn, T>>> Map(Stream<T> stream, TFn f)

    Map(naturalNumbers, [](int i) { return i * i; }); // 1, 4, 16, 64...
    ```

1. Функция `Zip` принимает 2 потока и соединяет их в один поток пар.
    ``` cpp
    template<class T1, class T2>
    Stream<std::pair<T1, T2>> Zip(Stream<T1> s1, Stream<T2> s2);

    Zip(naturalNumbers, powersOfTwo); // {1, 2}, {2, 4}, {3, 8}, {4, 16}...
    ```

1. Функция `Filter` возвращает поток из элементoв, которые удовлетворяют предикату `pred`.
    ``` cpp
    template<class T, class TFn>
    Stream<T> Filter(Stream<T> s, TFn pred)

    Filter(naturalNumbers, [](int i) { return i % 2 == 0; }); // 2, 4, 6, 8, 10...
    ```

1. Функция `GetRandomStream` возвращает поток псевдо-случайных чисел.
Причём если пройти по одному и тому же потоку несколько раз, каждый раз будет одинаковый результат.

### 2. Задание

Разведчикам нужна помощь!
Необходимо сгенерировать массив из 100 случайных имен и фамилий для работы под прикрытием.
Чтобы они не выглядели подозрительными, имена и фамилии, начинающиеся с одной буквы, запрещены.

Использовать CreateStream нельзя, все остальные функции - можно.
Имена и фамилии нужно брать из заранее подготовленного массива всех возможных имен.
