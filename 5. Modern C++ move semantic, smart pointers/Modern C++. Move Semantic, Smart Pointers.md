# Modern C++: Move Semantic. Smart Pointers
# Лабораторная работа № 5

Требуется выполнить как минимум одно задание.

###	1. Copy smart pointer

Написать «умный» указатель, который при копировании будет копировать хранящиеся в нем данные.

```
template <class T> class copy_ptr
{
   ...
};
```

Указатель также должен реализовывать move-конструктор и move-оператор присваивания. Данные функции должны передавать владение другому указателю вместо копирования.

В указателе также должны быть реализованы стандартные операторы и методы: `*`, `->`, `get`, `reset`, преобразование к `bool`.

Написать код, который продемонстрирует работу указателя.

Пример использования:

```
copy_ptr<string> ptr(new string("text"));
```

*Дополнительное задание 1:* написать функцию `make_copy`, аналогичную `make_unique` и `make_shared`.

*Дополнительное задание 2:* подумать, можно ли хранить указатель на базовый класс в таком «умном» указателе? Какие возникают проблемы и как их можно решить?

*Дополнительное задание 3:* сделать так, чтобы объект типа `copy_ptr<T>` можно было присвоить объекту `copy_ptr<const T>` и наоборот.
 
###	2. Caching factory

Написать «фабрику» `Factory`, которая умеет создавать объекты с интерфейсом `IAlgorithm`.

```
class IAlgorithm
{
public:
   virtual int Execute(int i_a, int i_b) = 0;
};

class Factory
{
public:
	shared_ptr<IAlgorithm> CreateAlgo(char i_op) { ... }
};
```

В качестве входного параметра фабрика должна принимать символ. Если передан символ ‘+’, то должен создаться объект, реализующий сложение; ‘-‘ – вычитание; ‘\*’ – умножение; ‘/’ – деление.

В программе запрещено использовать `new` и `delete`. Вместо них рекомендуется использование умных указателей и функции `make_shared`.

Фабрика должна иметь кэш созданных объектов на основе `shared_ptr`. Т.е. если объект уже был создан фабрикой и еще не удален, то следует вернуть указатель на этот объект.

Продемонстрировать работу фабрики. Проследить за временем жизни создаваемых объектов.

Пример использования:

```
int main(int argc, char* argv[])
{
   Factory factory;
   auto obj = factory.CreateAlgo('+');
   cout << obj->Execute(1, 2); // 3
   return 0;
}
```
*Дополнительное задание 1:* подумать, как можно обрабатывать деление на ноль.

*Дополнительное задание 2:* использовать `weak_ptr` вместо `shared_ptr` для кеша.

*Дополнительное задание 3:* сделать так, чтобы в кеше никогда не хранились "пустые" `weak_ptr`-ы на уже разрушенные объекты
