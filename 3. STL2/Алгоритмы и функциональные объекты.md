### STL: Алгоритмы и функциональные объекты
# Лабораторная работа № 3
### Задание к выполнению лабораторной работы.

### Вариант 1. Попроще.

Реализовать функциональный класс (функтор) `SymbolTester`, позволяющий проверить, что все символы, входящие в заданную подстроку, присутствуют в заданной строке. Например, все символы из подстроки «`abc`» присутствуют в строке «`charm of a butterfly`», но не все присутствуют в строке «`bank`».

Класс `SymbolTester` должен иметь:

- конструктор, принимающий подстроку как параметр:

```cpp
SymbolTester (const std::string& i_substr);
```

- функцию, возвращающую `true` или `false` в зависимости от того, все ли символы из подстроки `i_substr` были встречены в анализируемой строке:

```cpp
bool AreAllSymbolsFound() const;
```

Анализ вхождений символов из заданной подстроки в строке осуществляется путем передачи функционального объекта `SymbolTester`, инициализированного подстрокой, в алгоритм `for_each`, который принимает итераторы на начало и конец анализируемой строки. Функциональный объект, который вернет `for_each` как возвращаемое значение, должен содержать информацию о том, все ли символы встретились в строке.

Написать консольное приложение, которое демонстрирует работу функционального объекта в сочетании с `for_each` для разных сочетаний строки и подстроки с символами. Для тестирования можно использовать функцию `assert()` (требует `#include <cassert>`).


### Вариант 2. Похож, но поинтереснее.

Реализовать функциональный класс (функтор) `TokenCounter`, позволяющий пересчитать количество непересекающихся вхождений заданной подстроки в данной строке. Под «непересекающимися» вхождениями имеется в виду, что один символ строки не может входить сразу в две найденные подстроки: строка «`aaabb`» содержит подстроку «`aa`» только один раз.

Класс `TokenCounter` должен иметь:

- конструктор, принимающий подстроку для поиска как параметр:

```cpp
TokenCounter (const std::string& i_substr);
```

- функцию, возвращающую количество найденных вхождений:

```cpp
size_t GetTokenCount() const;
```
Пересчет вхождений заданной подстроки в строке осуществляется путем передачи функционального объекта `TokenCounter`, инициализированного подстрокой, в алгоритм `for_each`, который принимает итераторы на начало и конец строки, в которой будет осуществляться поиск. Функциональный объект, который вернет `for_each` как возвращаемое значение, должен содержать информацию о количестве найденных вхождений.

Написать консольное приложение, которое демонстрирует работу функционального объекта в сочетании с `for_each` для разных сочетаний строки и подстроки поиска. Для тестирования можно использовать функцию `assert()` (требует `#include <cassert>`).

